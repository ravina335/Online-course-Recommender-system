# -*- coding: utf-8 -*-
"""content based recommender using course sim(part5)rs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zCGJOvfge3h57bBE8WhKJ3Z4xLWo7C26
"""

# Commented out IPython magic to ensure Python compatibility.
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# %matplotlib inline

sim_url = "https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-ML321EN-SkillsNetwork/labs/datasets/sim.csv"
sim_df = pd.read_csv(sim_url)
sim_df

# Configure seaborn to set the plot style to 'white'
sns.set_theme(style="white")

# Create a mask for the upper triangle of the similarity matrix
mask = np.triu(np.ones_like(sim_df, dtype=bool))

# Create a new figure and axis for the heatmap
_, ax = plt.subplots(figsize=(11, 9))

# Create a diverging color palette for the heatmap
cmap = sns.diverging_palette(230, 20, as_cmap=True)

# Plot a similarity heat map using seaborn's heatmap function
sns.heatmap(sim_df, mask=mask, cmap=cmap, vmin=0.01, vmax=1, center=0,
            square=True)

# Let's first load the course content and BoW dataset
course_url = "https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-ML321EN-SkillsNetwork/labs/datasets/course_processed.csv"
course_df = pd.read_csv(course_url)
bow_url = "https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBM-ML321EN-SkillsNetwork/labs/datasets/courses_bows.csv"
bow_df = pd.read_csv(bow_url)

# Create course id to index and index to id mappings
def get_doc_dicts(bow_df):
    # Group the DataFrame by course index and ID, and get the maximum value for each group
    grouped_df = bow_df.groupby(['doc_index', 'doc_id']).max().reset_index(drop=False)
    # Create a dictionary mapping indices to course IDs
    idx_id_dict = grouped_df[['doc_id']].to_dict()['doc_id']
    # Create a dictionary mapping course IDs to indices
    id_idx_dict = {v: k for k, v in idx_id_dict.items()}
    # Clean up temporary DataFrame
    del grouped_df
    return idx_id_dict, id_idx_dict

course1 = course_df[course_df['COURSE_ID'] == "ML0151EN"]
course1

course2 = course_df[course_df['COURSE_ID'] == "ML0101ENv3"]
course2

idx_id_dict, id_idx_dict = get_doc_dicts(bow_df)
idx1 = id_idx_dict["ML0151EN"]
idx2 = id_idx_dict["ML0101ENv3"]
print(f"Course 1's index is {idx1} and Course 2's index is {idx2}")

sim_matrix = sim_df.to_numpy()

sim = sim_matrix[idx1][idx2]
sim

"""TASK: Find courses which are similar enough to your enrolled courses."""

pd.set_option('display.max_rows', None)
pd.set_option('max_colwidth', None)
course_df[['COURSE_ID', 'TITLE']]

# Reset pandas settings
pd.reset_option('display.max_rows')
pd.reset_option('max_colwidth')

enrolled_course_ids = [ ] # add your interested coures id to the list
enrolled_courses = course_df[course_df['COURSE_ID'].isin(enrolled_course_ids)]
enrolled_courses

all_courses = set(course_df['COURSE_ID'])
unselected_course_ids = all_courses.difference(enrolled_course_ids)
unselected_course_ids

def generate_recommendations_for_one_user(enrolled_course_ids, unselected_course_ids, id_idx_dict, sim_matrix):
    # Create a dictionary to store your recommendation results
    res = {}

    # Set a threshold for similarity
    threshold = 0.6

    # Iterate over enrolled courses
    for enrolled_course in enrolled_course_ids:
        # Iterate over unselected courses
        for unselect_course in unselected_course_ids:
            # Check if both enrolled and unselected courses exist in the id_idx_dict
            if enrolled_course in id_idx_dict and unselect_course in id_idx_dict:
                # Find the indices for each enrolled_course and unselected_course
                idx1 = id_idx_dict[enrolled_course]
                idx2 = id_idx_dict[unselect_course]

                # Calculate the similarity between the enrolled_course and the unselect_course
                sim = sim_matrix[idx1][idx2]

                # Check if the similarity exceeds the threshold
                if sim > threshold:
                    # Update recommendation dictionary with course ID and similarity score
                    if unselect_course not in res:
                        # If the unselected course is not already in the recommendation dictionary (`res`), add it.
                        res[unselect_course] = sim
                    else:
                        # If the unselected course is already in the recommendation dictionary (`res`), compare the similarity score.
                        # Update if current similarity is higher or equal
                        if sim >= res[unselect_course]:
                            res[unselect_course] = sim

    # Sort the results by similarity in descending order
    res = {k: v for k, v in sorted(res.items(), key=lambda item: item[1], reverse=True)}

    # Return the recommendation dictionary
    return res

test_users_url = "https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMSkillsNetwork-ML0321EN-Coursera/labs/v2/module_3/ratings.csv"
test_users_df = pd.read_csv(test_users_url)

def generate_recommendations_for_one_user(enrolled_course_ids, unselected_course_ids, id_idx_dict, sim_matrix):
    res = {}
    threshold = 0.6
    for enrolled_course in enrolled_course_ids:
        for unselect_course in unselected_course_ids:
            if enrolled_course in id_idx_dict and unselect_course in id_idx_dict:
                idx1 = id_idx_dict[enrolled_course]
                idx2 = id_idx_dict[unselect_course]
                sim = sim_matrix[idx1][idx2]
                if sim > threshold:
                    if unselect_course not in res:
                        res[unselect_course] = sim
                    else:
                        if sim >= res[unselect_course]:
                            res[unselect_course] = sim
    return {k: v for k, v in sorted(res.items(), key=lambda item: item[1], reverse=True)}

#  enrolled and unselected courses
enrolled_course_ids = ['ML0101ENv3']  # Example of an enrolled course
all_courses = set(course_df['COURSE_ID'])
unselected_course_ids = all_courses.difference(enrolled_course_ids)


recommendations = generate_recommendations_for_one_user(enrolled_course_ids, unselected_course_ids, id_idx_dict, sim_matrix)

# Display recommended courses and similarity scores
print("Recommended Courses and Similarity Scores:")
print(recommendations)

"""**TASK: Generate course recommendations based on course similarities for all test uesrs**"""

test_users_url = "https://cf-courses-data.s3.us.cloud-object-storage.appdomain.cloud/IBMSkillsNetwork-ML0321EN-Coursera/labs/v2/module_3/ratings.csv"
test_users_df = pd.read_csv(test_users_url)

test_users = test_users_df.groupby(['user']).max().reset_index(drop=False)
test_user_ids = test_users['user'].to_list()
print(f"Total numbers of test users {len(test_user_ids)}")

# Step 4: Function to generate recommendations for all users
def generate_recommendations_for_all():
    users = []
    courses = []
    sim_scores = []

    # Process test user dataframe
    test_users = test_users_df.groupby(['user']).max().reset_index(drop=False)
    test_user_ids = test_users['user'].to_list()
    all_courses = set(course_df['COURSE_ID'])

    # Loop through each user
    for user_id in test_user_ids:
        # Find enrolled courses for the user
        enrolled_course_ids = test_users[test_users['user'] == user_id]['item'].to_list()

        # Find unselected courses by taking the difference of all courses and enrolled courses
        unselected_course_ids = all_courses.difference(enrolled_course_ids)

        # Generate recommendations for the user
        recommendations = generate_recommendations_for_one_user(enrolled_course_ids, unselected_course_ids, id_idx_dict, sim_matrix)

        # Append results for this user
        users.append(user_id)
        courses.append(list(recommendations.keys()))  # List of recommended course IDs
        sim_scores.append(list(recommendations.values()))  # Corresponding similarity scores

    return users, courses, sim_scores

# Step 5: Call the function and display results
users, courses, sim_scores = generate_recommendations_for_all()
print(f"Total number of test users: {len(users)}")

# Example: Show the recommendations for the first user
print(f"User {users[0]} recommendations:")
for course, score in zip(courses[0], sim_scores[0]):
    print(f"Course: {course}, Similarity Score: {score}")





res_dict = {}
users, courses, sim_scores = generate_recommendations_for_all()
res_dict['USER'] = users
res_dict['COURSE_ID'] = courses
res_dict['SCORE'] = sim_scores
res_df = pd.DataFrame(res_dict, columns=['USER', 'COURSE_ID', 'SCORE'])
res_df.head(10)

